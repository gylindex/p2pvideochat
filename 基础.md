###### 外网ip

![image-20221016214311915](../image-20221016214311915.png)

- 每台电脑都有一个内网Ip：即局域网ip，还有一个外网ip
- 正常情况下，局域网ip可以发数据到外网，外网也可以发数据的局域网，但是局域网之间想要直接通信是不行的，局域网的主句一般都有一个内网ip和外网ip，外网ip之间是有可能互发数据的，如果也打不通，那就需要turn中继了
- 此时就需要NAT映射表来知道我们的外网ip
- ![image-20221016214652278](../image-20221016214652278.png)
- 怎么获取公网ip：向外网的服务器（STUN）发送一条数据，外网服务器可以返回我们的外网ip

###### STUN服务器

- STUN（SessionTraversalUtilitiesforNAT，NAT会话穿越应用程序）是一种网络协议，它允许位于NAT（或多重NAT）后的**客户端找出自己的公网地址**，查出自己位于哪种类型的NAT之后以及NAT为某一个本地端口所绑定的Internet端端口。这些信息被用来在两个同时处于NAT路由器之后的主机之间创建UDP通信。该协议由RFC5389定义。
- 使用一句话说明STUN做的事情就是：告诉我你的公网IP地址+端口是什么。搭建STUN服务器很简单，媒体流传输是按照P2P的方式。
- 使用STUN，获取公网ip+port，公网ip之间p2p打通，通话成功，公网ip之间p2p打不通，用TURN

###### TURN

- TURN的全称为TraversalUsingRelaysaroundNAT，是STUN/RFC5389的一个拓展，主要添加了Relay功能。如果终端在NAT之后，那么在特定的情景下，有可能使得终端无法和其对等端（peer）进行直接的通信，这时就需要公网的服务器作为一个中继，对来往的数据进行转发。这个转发的协议就被定义为TURN。
- 这种方式的带宽由服务器端承担（一般：单向数据200kbps一对一通话）
- 中继服务比较耗费服务器的带宽（200*4）

![image-20221017161040837](../image-20221017161040837.png)

###### conturn

- 以上是WebRTC中经常用到的2个协议，STUN和TURN服务器我们使用coturn开源项目来搭建。
- coturn开源项目集成了STUN和TURN的功能。

###### 媒体协商（SDP）和网络协商（candidate）--信令服务器

- 媒体协商（SDP）：交换媒体信息，确定双方的编码信息等
- 网络协商（candidate）：获取对方的公网ip和端口
- 信令服务器：转发彼此的媒体信息和网络信息。
  - 信令服务器不只是交互媒体信息sdp和网络信息candidate
  - 比如：（1）房间管理（2）人员进出房间

#### 一对一通话环境搭建

1. 通过信令服务器建立连接，确认信令服务器是打通的， 没问题的
2. 发起者通过回调函数获取自己的SDP，获取到了就设置自己的SDP，再通过信令服务器发送给接受者，接受者收到发起者的SDP后设置发起者的SDP，同样去获取自己的SDP、设置自己的SDP，再把SDP全发送给发起者，发起者收到后设置接受者的SDP
3. ![image-20221017173552569](../image-20221017173552569.png)
4. ICE是集成了TURN和STUN，来获取公网ip+port，发起者通过回调接口来获取这些信息，他会自动保存到PeerConnection里面，然后我们发送信息给接受者，接受者会保存下来，再以同样的方式获取自己的公网ip+port，发送给发起者，发起者也保存对方的网络信息
5. 双方获取了对方的公网ip+port之后，会尝试建立连接，注意，在获取网络信息的时候，不止获取了一个candidate，建立连接也不是只建立一次连接，是依次建立连接直到通道打通
6. ![image-20221017180444044](../image-20221017180444044.png)
7. ![image-20221017180607806](../image-20221017180607806.png)

在一对一通话场景中，每个Peer均创建有一个PeerConnection对象，由一方主动发OfferSDP，另一方则应答AnswerSDP，最后双方交换ICECandidate从而完成通话链路的建立。但是在中国的网络环境中，据一些统计数据显示，至少1半的网络是无法直接穿透打通，这种情况下只能借助TURN服务器中转。

###### 安装环境

==nodejs==

nodejs主要实现信令服务器的功能，也可以做web服务器

![image-20221017215322891](../image-20221017215322891.png)

![image-20221017215333594](../image-20221017215333594.png)

什么是==npm==和==cnpm==
npm（node package manager）：nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等） 
cnpm:因为npm安装插件是从国外服务器下载，受网络的影响比较大，可能会出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”

==conturn==

功能：获取公网ip+port的功能

![image-20221017220610472](../image-20221017220610472.png)

![image-20221017220619167](../image-20221017220619167.png)

###### 测试coturn

```shell
#后台运行coturn，日志重定向到当前目录的nohup.out文件中；
#gyl:123456是用户名和密码，随便输，使用这个服务器要用到这个密码
nohup turnserver -L 0.0.0.0 -a -u gyl:123456 -v -f -r nort.gov &
#测试网址
https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/
```

###### websocket

- websocket和http的区别：
  - 允许服务端主动向客户端推送数据。
  - 浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。

###### p2p网络穿透原理

核心：NAT映射表，通过NAT映射表一层层的找到离对方最近的网关，进行端到端的直接通信，不经过服务器，但是端到端通信要启动的话必须要借助服务器，服务器的作用是帮助获得对方的ip和端口

==NET分类==

- 原因是NAT的类型不同

![image-20221025165533693](../image-20221025165533693.png)

- 分四种：对称NAT，完全锥形NAT，端口限制锥形NAT，IP限制锥形NAT
- 完全锥形NAT：不管是谁，都可以穿透
- IP限制锥形NAT：只允许指定IP的访问穿透
- 端口限制锥形NAT：只允许指定IP，指定端口的访问进去
- 对称NAT：局域网下的主机向外发数据，经过网关时，网关会为主机进程映射一条ip+port，注意，ip是网关的公网IP，port是随机生成的，是唯一的，对称NAT在主机向不同的目标发送数据时，分配的映射端口是不一样的，虽然极难穿透

结论：

- 完全锥形NAT可以100%被穿透，限制锥形NAT可能被穿透，对称锥形NAT很难被穿透
- 锥形NAT下，同一个主机的同一个进程映射的结果是一样的，不管给谁发数据，都是用的这个映射，对称型NAT相反，给不同的ip发数据，NAT为他映射的端口都不一样

==怎么辨别NAT类型==

检测网关类型是在打洞服务器上进行的，方便后边打洞用

第一：检测是不是对称NAT，是--》结束

![image-20221025171706938](../image-20221025171706938.png)

第二：检测是不是完全锥形NAT，是--》结束

![image-20221025172521406](../image-20221025172521406.png)

第三：检测是不是IP限制锥形NAT，是--》结束

![image-20221025173534546](../image-20221025173534546.png)

第四：都不是，那就是端口限制锥形NAT

==需要关注的三种P2PNET情况==

1. 一端为完全锥形NAT
2. 两端都是限制锥形NAT
3. 两边都是对称NAT/或者一边是限制锥形NAT另一边是对称NAT

注意：只要一端通，就可以直接打通，打通的原理是，**只要两端能进行一个发送-回复的过程就通了**

###### 穿透的本质

- 穿透的本质是：获取对方的公网ip和端口号，这个端口号NAT映射生成的端口号，然后两端完成发送-回复
- 两边都不通的情况下如何穿透：A向B发一条数据，B收不到，A马上向服务器发一条数据，服务器转发给B，让B回复A一条数据，虽然A也是不通是，但是A会认为这是B收到他的数据后回复他的，A就会接收这条数据，打洞完成

#### 一对一通话原理

nginx监听https：443，服务器：8080，客户端访问：8081，nginx代理到8080

![image-20221024105340187](../image-20221024105340187.png)

- 服务器目录：`/home/gyl/develop/webrtc/node/one2oneqq/server`

- nginx目录：`/home/gyl/develop/webrtc/node/one2oneqq/nginx-1.15.8/conf`，其他nginx也可以，但是必须支持https，并且配置无误
- 客户端页面代码目录：`/home/gyl/develop/webrtc/node/one2oneqq/client`

1. 信令设计：信令服务器不仅担任网络协商（交换IP+port）、媒体协商（确定编码）的功能，还担任通话管理员的职责，管理双方的加入和退出
2. 媒体协商
3. 加入Stream/Track
4. 网络协商

###### 页面设计

- 页面设计主要是html文件设计
- html语法参考：https://www.runoob.com/tags/tag-div.html

```html
<!DOCTYPE html>
<html>

<head>
<!-- title 字段是网页的页面标签 -->
    <title>WebRTC AVC</title>

    <link rel="stylesheet" href="css/main.css" />

</head>

<body>
<!-- h1相当于是一级标题，是页面正文里面显示 -->
    <h1>LinLin版视频通话</h1>
<!-- div标签：划分块 ，块的名字叫buttons，随便取的-->
    <div id="buttons">
        <input id="gyl-roomId" type="text"   placeholder="我们的生日6位" maxlength='40'/>
        <button id="joinBtn" type="button">加入</button>
        <button id="leaveBtn" type="button">离开</button>
    </div>
    <!-- 划分一个播放视频的块，静音播放本地的，播放远端的 注意：视频控件的id要匹配，这里的视频控件只是一个空壳，js文件里要向这个控件里填入数据-->
    <div id="videos">
        <video id="localVideo" autoplay muted playsinline></video>
        <video id="remoteVideo" autoplay playsinline></video>
    </div>
<!-- 引用js的文件 -->
    <script src="js/adapter-latest.js"></script>
    <script src="js/main.js"></script>

</body>

</html>
```

###### 打开摄像头

```javascript
'use strict';
// 根据Html里面的控件id拿到视频控件
var localVideo = document.querySelector('#localVideo');
var remoteVideo = document.querySelector('#remoteVideo');
var localStream = null;
// 初始化本地媒体流
function initLocalStream(){
    navigator.mediaDevices.getUserMedia({//js中很多函数的返回值都是promise，都可以.then和.catch，是异步执行的，我靠，相当于多线程
        audio: true,
        video: true
    })//getUserMedia执行完毕，异步执行，宏观上边执行then，一边执行其他的
        .then(openLocalStream)//初始化之后就马上打开本地媒体流
        .catch(function (e) {//如果出错
            alert('getUserMedia() error: ' + e.name);//打印错误信息
        });
}
//打开本地媒体流，
function openLocalStream(stream) {//promise的then是带了一个返回值的，then调用的函数就用它当参数
    doJoin(roomId);

    console.log('Open local video stream');
    localVideo.srcObject = stream;//stream就是视频流
    localStream = stream;//备份一份流传到远端
}
// 通过id拿到加入按钮控件.onclick表示添加一个点击事件，点击事件的响应函数就是后边的function
document.getElementById('joinBtn').onclick = function () {
    roomId = document.getElementById("gyl-roomId").value; 
    if (roomId == "" || roomId == "请输入房间ID") {
        alert("请输入房间ID");
        return;
    }
    console.log('doJoin roomId: ' + roomId);
    initLocalStream();
};

document.getElementById('leaveBtn').onclick = function () {
    console.log('doLeave');
    doLeave(roomId);
};
```

###### websocket连接

1. 创建websocket对象
2. 注册事件回调

```javascript
var zeroRTCEngine;//一个类
var ZeroRTCEngine = function (wsUrl) {//相当于构造函数，构造ZeroRTCEngine类
    this.init(wsUrl);
    zeroRTCEngine = this;
    return this;
}

ZeroRTCEngine.prototype.init = function (wsUrl) {
    // 设置websocket  url
    this.wsUrl = wsUrl;
    /** websocket对象 */
    this.signaling = null;
}
//创建Websocket，new一个Websocket对象，注册连接、收到数据、出错、关闭的处理函数
ZeroRTCEngine.prototype.createWebsocket = function () {
    var zeroRTCEngine = this;
    zeroRTCEngine.signaling = new WebSocket(this.wsUrl);
    zeroRTCEngine.signaling.onopen = function () {//设置onopen的回调
        zeroRTCEngine.onOpen();
    };
    zeroRTCEngine.signaling.onmessage = function (ev) {
        zeroRTCEngine.onMessage(ev);
    };
    zeroRTCEngine.signaling.onerror = function (ev) {
        console.error("连接websocket失败请重试, msg:" + ev);
        zeroRTCEngine.onError(ev);
    };
    zeroRTCEngine.signaling.onclose = function (ev) {
        zeroRTCEngine.onClose(ev);
    };
};

ZeroRTCEngine.prototype.sendJsonMessage = function (parameters) {
    var message = JSON.stringify(parameters);
    this.signaling.send(message);
};
ZeroRTCEngine.prototype.sendMessage = function (message) {
    this.signaling.send(message);
};
/**
 * onOpen
 * 连接上WebScoekt的处理
 */
ZeroRTCEngine.prototype.onOpen = function () {
    console.info('websocket open');
}

function parseJSON(json) {
    try {
        return JSON.parse(json);
    } catch (e) {
        console.error("Error parsing json: " + json);
    }
    return null;
}
/** onMessage
 * WebSocket收到数据时的处理
 * @param {*} event 
 * @returns 
 */
ZeroRTCEngine.prototype.onMessage = function (event) {
    console.info("onMessage: " + event.data);
    var message = parseJSON(event.data);
    if(message == null) {
        console.error("parse msg:" + message + " failed");
        return;
    }
    switch (message.cmd) {
        case SIGNAL_TYPE_RESP_JOIN:
            handleResponseJoin(message);
            return;
        case SIGNAL_TYPE_NEW_PEER:  // 其他人进来
            handleRemoteNewPeer(message);
            return;
        case SIGNAL_TYPE_PEER_LEAVE:  // 其他人进来
            handleRemotePeerLeave(message);
            return;
        case SIGNAL_TYPE_OFFER:
            handleRemoteOffer(message);
            return;
        case SIGNAL_TYPE_ANSWER:
            handleRemoteAnswer(message);
            return;
        case SIGNAL_TYPE_CANDIDATE:
            handleRemoteCandidate(message);
            return;    
        default:
            console.warn('Event ' + message.cmd);
    }
};
/**
 * onClose
 *
 */
ZeroRTCEngine.prototype.onClose = function (ev) {
    var ecerRTCEnv = this;
    console.warn('websocket close', ev);
    if (ev.code == 1000 && ev.reason == 'wsForcedClose') { // 如果自定义关闭ws连接，避免二次重连
        return;
    }
};
/**
 * onError
 * 相当于WebSocket的错误处理
 */
ZeroRTCEngine.prototype.onError = function (ev) {
    console.error('websocket error', ev);
};

zeroRTCEngine = new ZeroRTCEngine("ws://120.24.5.163:7777");
zeroRTCEngine.createWebsocket();
```

###### 总体逻辑

![image-20221021162405625](../image-20221021162405625.png)

#### 部署到公网

###### 1.启动coturn

- 要部署到公网，必须启动coturn服务器，客户端在创建RTCPeerConnection的时候，也必须配置turn和stun服务器的参数

- 如果不配置或者配置成all，就算coturn服务器关闭仍然能够在局域网之下通信

- 总之一句话，在局域网之下，不配置或是配置成all，怎么都能p2p，在公网之下，不配置并且启动coturn，怎么都通不了话

- ```javascript
  function createPeerConnection() {
      try {
          var defaultConfiguration = {  
              bundlePolicy: "max-bundle",
              rtcpMuxPolicy: "require",
              iceTransportPolicy:"relay",//relay 或者all  all允许做p2p  relay只能中继
              // 修改ice数组测试效果，需要进行封装
              iceServers: [
                  {
                      "urls": [
                          "turn:120.24.5.163:3478?transport=udp",
                          "turn:120.24.5.163:3478?transport=tcp"       // 可以插入多个进行备选
                      ],
                      "username": "gyl",
                      "credential": "123456"
                  },
                  {
                      "urls": [
                          "stun:120.24.5.163:3478"
                      ]
                  }
              ]
          };
  
          pc = new RTCPeerConnection(defaultConfiguration);//这里必须传入coturn配置信息，不配置传null
          // 获取到candidate事件  这是回调函数，是收到answer自动被调用的，与coturn客户端交互的
          pc.onicecandidate = handleIceCandidate;
          // 远端码流加入事件
          pc.ontrack = handleRemoteStreamAdded;
          // 远端码流删除事件
          pc.onremovestream = handleRemoteStreamRemoved;
           // sdp信令状态
          pc.onsignalingstatechange = handleSignalingStateChange;
          // Peer连接状态
          pc.onconnectionstatechange = handleConnectionStateChange;
          // 用于描述连接的ICE连接状态
          pc.oniceconnectionstatechange = handleIceconnectionStateChange;
          //localStream:本地媒体流
          localStream.getTracks().forEach((track) => pc.addTrack(track, localStream));
          console.log('RTCPeerConnnection Created');
      } catch (e) {
          console.log('Failed to create PeerConnection, exception: ' + e.message);
          alert('Cannot create RTCPeerConnection object.');
          return;
      }
  }
  ```

- 查看网络状况的工具：sudo sar -n DEV 1，1表示1s刷新一次

- 设置为all，p2p通话时的coturn服务器vim码率和收发包数量

- ![image-20221021163254643](../image-20221021163254643.png)

- 设置为relay，coturn转发通话时的coturn服务器码率和收发包数量

- ![image-20221021163438705](../image-20221021163438705.png)

###### 2.配置nginx

- 为什么要配置nginx？

  - 首先，nodejs作为web服务器的话只支持http，要用https的话就必须用nginx把https代理成http
  - 其次，可以发现，如果要用这个一对一通话，我们必须拿到客户端代码，也就是html和js文件，我们双击html文件可以打开客户端，也会去尝试连接到服务器，
  - 那么就有一个缺点，难道必须有这个文件才能通话吗？配置nginx就能解决这个问题。
  - 总之，nginx还能作为一个web服务器让我们拿到js代码，但其实nodejs也支持作为web服务器，主要还是第一点
  - 把客户端代码传到云服务器里去，nginx配置中加入这个路径，并配置一个域名或ip，我们只需要请求这个域名，服务器就会传回客户端页面，做到随时随地访问，不需要准备任何东西，只需要能上网，有浏览器就行
  
  - ![image-20221021202641684](../image-20221021202641684.png)
  - 因为我们要配置https，https相当于wss，是安全的，http相当于ws，是不安全的，https无法降级访问ws
  - 要用我们通过nginx的https访问443端口，拿到服务器的html页面文件，然后html页面文件中的客户端是用wss访问的nginx的7778端口，nginx为我们代理到7777端口，7777端口是nodejs信令服务器，与信令服务器建立起ws连接

  ==配置文件==

  1. 准备工作

     - 安装nginx，要支持https

     - 准备好域名，以及域名申请的证书，没有域名就用openssl生成证书

     - 一定要开启80、443、7777、7778、等端口，nginx，nodejs，coturn涉及到的都要打开
  
     - ```shell
       # 配置，一定要支持https
       ./configure ‐‐with‐http_ssl_module
       #产生证书  应该在nginx的conf目录下创建
       mkdir cert
       cd cert
       # CA私钥
       openssl genrsa ‐out key.pem 2048
       # 自签名证书
       openssl req ‐new ‐x509 ‐key key.pem ‐out cert.pem ‐days 1095
       ```

  2. 配置web服务器

     - 在conf目录下创建conf.d目录

     - 在conf.d目录下创建webrtc­https.conf文件

     - 在conf目录下自带的配置文件nginx.conf的末尾}之前添加一句`include ./conf.d/*.conf;`，这样conf.d下的配置文件会加进来
  
     - ```shell
       server {
               listen 443 ssl;		#一定要开放443端口
               ssl_certificate         cert/7504997_gongyuanlin.cn.pem;
               ssl_certificate_key     cert/7504997_gongyuanlin.cn.key;
               charset utf‐8;
               # ip地址或者域名
               server_name gongyuanlin.cn;
               location / {
               add_header 'Access‐Control‐Allow‐Origin' '*';
               add_header 'Access‐Control‐Allow‐Credentials' 'true';
               add_header 'Access‐Control‐Allow‐Methods' '*';
               add_header 'Access‐Control‐Allow‐Headers' 'Origin, X‐Requested‐With, Content‐Type,Accept';
               # web页面所在目录
               root    /home/gyl/develop/webrtc/node/one2oneqq/client;
               index   index.php index.html index.htm;
           }
       #这个是https的server，访问根目录，返回client下的html文件
       }
       ```

  3. 配置websocket代理

     - Nginx主要是提供wss连接的支持，https必须调用wss的连接

     - 在conf.d目录下创建`webrtc­websocket­proxy.conf`文件
  
     - ```shell
       map $http_upgrade $connection_upgrade{
           default upgrade;
           '' close;
       }
       upstream websocket{
           server 120.24.5.163:7777;
       }
       server{
           listen 7778 ssl;
           #ssl on;
           ssl_certificate     cert/7504997_gongyuanlin.cn.pem;
           ssl_certificate_key cert/7504997_gongyuanlin.cn.key;
           server_name gongyuanlin.cn;
           location /ws{
           proxy_pass http://websocket;
           proxy_http_version 1.1;
           proxy_set_header Upgrade $http_upgrade;
           proxy_set_header Connection $connection_upgrade;
           }
       }
       
       ```

  4. 解决websocket自动断开

     - 我们在通话时，出现60秒后客户端自动断开的问题，是因为经过nginx代理时，如果websocket长时间没有收发消息则该websocket将会被断开。我们这里可以修改收发消息的时间间隔。

     - proxy_connect_timeout :后端服务器连接的超时时间_发起握手等候响应超时时间

     - proxy_read_timeout:连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）
  
     - proxy_send_timeout :后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据
       nginx使用proxy模块时，默认的读取超时时间是60s
  
     - ```shell
       map $http_upgrade $connection_upgrade{
           default upgrade;
           '' close;
       }
       upstream websocket{
           server 120.24.5.163:7777;
       }
       server{
           listen 7778 ssl;
           #ssl on;
           ssl_certificate     cert/7504997_gongyuanlin.cn.pem;
           ssl_certificate_key cert/7504997_gongyuanlin.cn.key;
           server_name gongyuanlin.cn;
           location /ws{
           proxy_pass http://websocket;
           proxy_http_version 1.1;
           proxy_connect_timeout 4s; #配置点1
           proxy_read_timeout 6000s; #配置点2，如果没效，可以考虑这个时间配置长一点
           proxy_send_timeout 6000s; #配置点3
           proxy_set_header Upgrade $http_upgrade;
           proxy_set_header Connection $connection_upgrade;
           }
       }
       ```

     - 上面这个方法比较粗暴，极端一点，6000s是100分钟，超过这个时间就被断开了

     - 正确的做法是：
  
     - 客户端 ­ 服务器  信令：心跳包
       keeplive 间隔5秒发送一次给信令服务器，说明客户端一直处于活跃的状态

###### 3.重要

- 最终部署到云服务器上的时候，不知道为啥，设置成relay模式不行，设置成all可以

- 整个流程比较复杂

  1. 先请求html页面，这个https是443端口，如果是http就是80端口，是在nginx中配好客户端代码路径就行

  2. 页面请求回来之后，客户端绑定的wss端口是7778，但服务器上信令服务器是7777端口，而且是ws协议，这么弄的原因是我们是用的https安全连接，服务器是ws不安全的连接，https只能对应wss协议，所以客户端是通过https发送wss数据，服务器上nginx再把7778端口的wss代理到7777端口的ws，这样才完成信令服务器的访问，并且信令服务器的连接是通过建立的，nginx有超时退出机制，如果一定时间内没有发数据，就会退出信令服务器

     

#### AppRTC

百度网盘参考文件：https://pan.baidu.com/disk/pdfview?path=%2F%E7%A0%94%E7%A9%B6%E7%94%9F%E5%AD%A6%E4%B9%A0%2F%E9%9F%B3%E8%A7%86%E9%A2%91%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%2F%E8%B5%84%E6%96%99%2F22-28-WebRTC%E4%B8%AD%E7%BA%A7%2FAppRTC%E6%90%AD%E5%BB%BA20190830.pdf&fsid=165669103570473&size=803552

###### 环境安装

- 安装nodejs
- 安装python：必须是python2.x版本
- 安装google_appengine
- 安装go
-  安装apprtc
- 安装coturn
- 安装Nginx：一定要支持https

###### 配置与运行

各个服务器对应的端口号

![image-20221024165537138](../image-20221024165537138.png)

1. 启动coturn 打洞+中继服务器：用于NAT穿透，后台启动失败的话试试前台启动一次再后台启动
2. 启动collider 信令服务器： 注意端口号和ip，这里要带上房间服务器的IP和端口
3. 配置启动apprtc 房间服务器：
   - 安装pip：有问题，python2.7版本问题，指定requests版本安装pip install requests==2.1
   - 修改配置文件： `vim /home/gyl/develop/webrtc/apprtc/src/app_engine/constants.py`
   - 编译：cnpm install会失败，原因是cnpm版本太高，nodejs版本过低，可以升级nodejs也可以安装低版本的cnpm
     - 降低cnpm的版本：删除已安装的cnpm版本（npm uninstall -g cnpm）
     - 安装低版本cnpm：npm install cnpm@7.1.0 -g --registry=https://registry.npm.taobao.org
   - 前台启动：/home/gyl/develop/webrtc/google_appengine/dev_appserver.py --host=0.0.0.0 --port=7779 /home/gyl/develop/webrtc/apprtc/out/app_engine --skip_sdk_update_check
   - 报错：ImportError: cannot import name RAND_egd，打开socket.py文件/home/gyl/develop/webrtc/google_appengine/google/appengine/dist27/socket.py，在第73行找到RAND_egd，删除他，下面是删除之后的图
   - ![image-20221025092535961](../image-20221025092535961.png)
   - 运行，访问https://www.gongyuanlin.cn，成功，
4. 解决跨域问题
   - 在文件/home/gyl/develop/webrtc/apprtc/src/web_app/js/appcontroller.js 中添加一行
   - 然后重新grunt build，会发现有个错误，根据他的提示，执行npm install --dev coffeescript，完成后再次grunt build，报错消失



